#!/usr/bin/env bash

#shellcheck source=shell-and-scripting-helpers/.qfuncs.sh
source "$(dirname "$0")"/shell-and-scripting-helpers/.qfuncs.sh

set -e -o pipefail
shopt -s dotglob lastpipe

# Array to track temporary files and directories for cleanup
cleanup_targets=()

# Cleanup function that will run on exit/error
cleanup() {
   local exit_code=$?

   # Clean up all tracked temporary files and directories
   for target in "${cleanup_targets[@]}"; do
      if [[ -n "$target" && -e "$target" ]]; then
         if [[ -d "$target" ]]; then
            rm -rf "$target"
         else
            rm -f "$target"
         fi
      fi
   done

   # Exit with the original exit code
   exit $exit_code
}

# Set trap to run cleanup on EXIT, ERR, INT, and TERM signals
trap cleanup EXIT ERR INT TERM

# Function to register files/directories for cleanup
register_for_cleanup() {
   cleanup_targets+=("$@")
}

if [ $# -eq 0 ] || [[ $1 =~ ^--?h(elp)?$ ]]; then
   cat - <<EOM
USAGE:
   $cmd_base [OPTIONS] TEXT_FILE [TEXT_FILE2 ...]

WTF:
   Convert text file(s) to audio using Piper TTS.
   Supports batch processing with ID3 tagging.
   On first run, if no Piper voices found, the script will prompt to run 
   piper-voices-setup which downloads a bunch of voices.

OPTIONS:
   -u / --update-voices (update installed Piper voices)
   -r / --random-voice (use a random voice for each file)
   -l / --list-voices (list voices installed)
EOM
   exit 1
fi

mapfile -t voices_installed < <(fd . -e onnx ~/.local/share/piper/voices)
if [ ${#voices_installed[@]} -eq 0 ]; then
   hline running piper-voices-setup
   show_cmd_execute ~/bin/piper-voices-setup
fi

list_installed_voices() {
   if [ ${#voices_installed[@]} -eq 0 ]; then
      errortext "No voices installed."
   else
      echo "INSTALLED VOICES:"
      for voice in "${voices_installed[@]}"; do
         display_voice="$(basename "$voice" .onnx)"
         case "$display_voice" in
         en_GB-*)
            echo -n "🇬🇧"
            ;;
         en_US-*)
            echo -n "🇺🇸"
            ;;
         *)
            echo -n "🌍"
            ;;
         esac
         echo -n "$display_voice "
         case "$display_voice" in
         *-high)
            echo "⭐️⭐️⭐️"
            ;;
         *-medium)
            echo "⭐️⭐️"
            ;;
         *-low)
            echo "⭐️"
            ;;
         esac
      done
      cat <<EOM
For Piper voices, medium is usually good enough, best trade-off between 
speed and quality. High quality voices may produce better results, but
require significantly more processing time.
EOM
   fi
}

# defaults
random=false
random_filter=.
source_files=()

while [ $# -gt 0 ]; do
   case "$1" in
   -r* | --random*)
      random=true
      # get random_filter from `--random=<filter>`
      random_filter="${1#*=}"
      if [[ "$1" != *"="* ]] || [ -z "$random_filter" ]; then
         random_filter=.
      else
         info "Using random filter: $random_filter"
      fi
      ;;
   -u | --update-voices)
      cd "$cmd_base"
      show_cmd_execute ./piper-voices-setup
      exit $?
      ;;
   -l | --list-voices)
      list_installed_voices
      exit $?
      ;;
   *)
      source_files+=("$1")
      ;;
   esac
   shift
done

# declare -p random random_filter source_files voices_installed cleanup_targets
# exit

info "The following metadata will be applied to all $# files specified, if entered."
# Prompt for author and book (optional)
echo -n "Enter author name (optional): "
read -r author
echo -n "Enter book title (optional): "
read -r book_title

# Function to extract track number from filename
extract_track_number() {
   local filename="$1"
   local basename
   basename=$(basename "$filename" .txt)

   # Look for clear integers in the filename
   if [[ $basename =~ ([0-9]+) ]]; then
      echo "${BASH_REMATCH[1]}"
   else
      echo ""
   fi
}

# Function to convert a single file
convert_file() {
   local input_text_file="$1"

   if $random; then
      read -r voice_model < <(fd "$random_filter" -e onnx ~/.local/share/piper/voices | shuf | head -n 1)
      info "Using random voice: $(basename "$voice_model")"
   fi

   if [ -z "$voice_model" ]; then
      die "No voice model could be determined"
   fi

   # Generate output filename based on input
   local target_mp3="${input_text_file}.mp3"

   hline "$(basename "$input_text_file") -> $target_mp3"

   mv_bak_if "$target_mp3"

   local tmpdir txt wav temp_tagged

   read -r tmpdir < <(mktemp -d)
   txt="$tmpdir/tmp.txt"
   wav="$tmpdir/tmp.wav"

   register_for_cleanup "$tmpdir" "$txt" "$wav"

   info "Converting $input_text_file to plain text"
   pandoc "$input_text_file" --to plain --wrap=none -o "$txt"

   #  clean up text, from experience we need to
   #  - remove all html/xml artefacts
   #  - convert markdown links [description](url) to just description
   #  - remove all { and } tags and anything within those tags
   #  - remove any lines beginning with :::
   #  - remove all backslashes
   #  - remove image references like !(OEBPS/image_rsrc2J4.jpg)
   #  - remove markdown image links like ![alt text(path)](url)

   sed -i -e 's/<[^>]*>//g' \
      -e 's/!\[[^]]*\](\([^)]*\))//g' \
      -e 's/!([^)]*)//g' \
      -e 's/\[\([^]]*\)\](\([^)]*\))/\1/g' \
      -e 's/{[^}]*}//g' \
      -e '/^:::/d' \
      -e 's/\\//g' \
      -e 's/\[\]//g' \
      -e 's/\[/*/g' \
      -e 's/\]/*/g' \
      -e 's/\n\n/[============]/g' \
      -e 's/\n//g' \
      -e 's/\[============\]/\n\n/g' \
      "$txt"

   declare -l txt_lines txt_bytes
   read -r txt_lines < <(wc -l "$txt")
   read -r txt_bytes < <(wc -c <"$txt")
   format_commas "$txt_bytes" txt_bytes_formatted

   info "Converted $input_text_file to plain text with $txt_lines lines\n($txt_bytes_formatted bytes)"

   info "Converting $txt_lines of plain text to raw audio ... stand by"
   pv <"$txt" | piper --model "$voice_model" \
      --output-file "$wav"

   info "Now converting raw WAV audio to MP3"
   ffmpeg -i "$wav" "$target_mp3"

   info "Tidying up ..."
   rm -f "$txt" "$wav"
   rm -rf "$tmpdir"

   # Set ID3 tags if author or book title provided
   if [ -n "$author" ] || [ -n "$book_title" ]; then
      info "Setting ID3 tags for $target_mp3"

      local tag_args=()

      if [ -n "$author" ]; then
         tag_args+=(-metadata "artist=$author")
         tag_args+=(-metadata "album_artist=$author")
      fi

      if [ -n "$book_title" ]; then
         tag_args+=(-metadata "album=$book_title")
      fi

      # Try to extract track number from filename
      local track_num
      track_num=$(extract_track_number "$input_text_file")
      if [ -n "$track_num" ]; then
         tag_args+=(-metadata "track=$track_num")
         info "Detected track number: $track_num"
      fi

      # Create a temporary file for retagging
      temp_tagged="$(mktemp).mp3"
      register_for_cleanup "$temp_tagged"
      ffmpeg -i "$target_mp3" "${tag_args[@]}" -c copy "$temp_tagged"
      mv "$temp_tagged" "$target_mp3"
   fi

   checktext "$target_mp3"
}

# Process all input files
declare -a successes
declare -a fails

if ! $random; then
   voice_model=$(find ~/.local/share/piper/voices -name "*.onnx" | fzf --height 40% --reverse --prompt="Select voice model: ")
fi

for source_file in "${source_files[@]}"; do
   if [ ! -f "$source_file" ]; then
      warn "File not found: $source_file - skipping"
      fails+=("$source_file")
      continue
   fi

   info "Processing file: $source_file"
   if convert_file "$source_file"; then
      successes+=("$source_file")
   else
      fails+=("$source_file")
   fi
done

[ ${#successes} -eq 0 ] || info Successfully processed:
for success in "${successes[@]}"; do
   echo "• $success"
done

[ ${#fails} -eq 0 ] || errortext Failed to process:
for fail in "${fails[@]}"; do
   echo "• $fail"
done

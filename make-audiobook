#!/usr/bin/env bash

#shellcheck source=shell-and-scripting-helpers/.qfuncs.sh
source ~/.qfuncs.sh

set -e -o pipefail
shopt -s dotglob lastpipe

# Array to track temporary files and directories for cleanup
cleanup_targets=()

# Cleanup function that will run on exit/error
cleanup() {
    local exit_code=$?
    
    # Clean up all tracked temporary files and directories
    for target in "${cleanup_targets[@]}"; do
        if [[ -n "$target" && -e "$target" ]]; then
            if [[ -d "$target" ]]; then
                rm -rf "$target"
            else
                rm -f "$target"
            fi
        fi
    done
    
    # Exit with the original exit code
    exit $exit_code
}

# Set trap to run cleanup on EXIT, ERR, INT, and TERM signals
trap cleanup EXIT ERR INT TERM

# Function to register files/directories for cleanup
register_for_cleanup() {
    cleanup_targets+=("$@")
}

if [ $# -eq 0 ] || [[ $1 =~ ^--?h(elp)?$ ]]; then
   cat - <<EOM
USAGE:
   $cmd_base [OPTIONS] TEXT_FILE [TEXT_FILE2 ...]

WTF:
   Convert text file(s) to audio using Piper TTS.
   Supports batch processing with ID3 tagging.
   On first run, if no Piper voices found, the script will prompt to run 
   piper-voices-setup which downloads a bunch of voices.

OPTIONS:
   -u / --update-voices (update installed Piper voices)
   -r / --random-voice (use a random voice for each file)
EOM
   exit 1
fi



mapfile -t voices_installed < <(fd . -e onnx ~/.local/share/piper/voices)
if [ ${#voices_installed[@]} -eq 0 ]; then
   hline running piper-voices-setup
   show_cmd_execute ~/bin/piper-voices-setup
fi

if [[ $1 =~ ^--?u(pdate-voices)?$ ]]; then
   show_cmd_execute ~/bin/piper-voices-setup
   hline
   shift
elif [[ $1 =~ ^--?r(andom)-?(voice|high|medium|low)?$ ]]; then
   random=true
   if [ -n "${BASH_REMATCH[2]}" ]; then
      filter="${BASH_REMATCH[2]}"
   else
      filter=.
   fi
   warn "Using random voices with filter $filter"
   shift
else
   random=false
   # select voice from ~/.local/share/piper/voices using fzf
   voice_model=$(find ~/.local/share/piper/voices -name "*.onnx" | fzf --height 40% --reverse)

   # voice_model=~/.local/share/piper/voices/en_US-ryan-high.onnx
   # voice_model=~/.local/share/piper/voices/en_US-libritts_r-medium.onnx

fi

info "The following metadata will be applied to all $# files specified, if entered."
# Prompt for author and book (optional)
echo -n "Enter author name (optional): "
read -r author
echo -n "Enter book title (optional): "
read -r book_title

# Function to extract track number from filename
extract_track_number() {
   local filename="$1"
   local basename
   basename=$(basename "$filename" .txt)

   # Look for clear integers in the filename
   if [[ $basename =~ ([0-9]+) ]]; then
      echo "${BASH_REMATCH[1]}"
   else
      echo ""
   fi
}

# Function to convert a single file
convert_file() {
   local structured_text="$1"

   if $random; then
      read -r voice_model < <(fd "$filter" -e onnx ~/.local/share/piper/voices | shuf | head -n 1)
      warn "Using random voice: $(basename "$voice_model")"
   fi

   # Generate output filename based on input
   local target_mp3="${structured_text%.txt}.mp3"

   hline "$(basename "$structured_text") -> $target_mp3"

   mv_bak "$target_mp3"

   local tmpdir txt wav temp_tagged

   read -r tmpdir < <(mktemp -d)
   txt="$tmpdir/tmp.txt"
   wav="$tmpdir/tmp.wav"

   register_for_cleanup "$tmpdir" "$txt" "$wav"

   info "Converting $structured_text to plain text"
   pandoc "$structured_text" --to plain --wrap=none -o "$txt"

   #  clean up text, from experience we need to
   #  - remove all html/xml artefacts
   #  - convert markdown links [description](url) to just description
   #  - remove all { and } tags and anything within those tags
   #  - remove any lines beginning with :::
   #  - remove all backslashes
   #  - remove image references like !(OEBPS/image_rsrc2J4.jpg)
   #  - remove markdown image links like ![alt text(path)](url)

   sed -i -e 's/<[^>]*>//g' \
      -e 's/!\[[^]]*\](\([^)]*\))//g' \
      -e 's/!([^)]*)//g' \
      -e 's/\[\([^]]*\)\](\([^)]*\))/\1/g' \
      -e 's/{[^}]*}//g' \
      -e '/^:::/d' \
      -e 's/\\//g' \
      -e 's/\[\]//g' \
      -e 's/\[/*/g' \
      -e 's/\]/*/g' \
      -e 's/\n\n/[============]/g' \
      -e 's/\n//g' \
      -e 's/\[============\]/\n\n/g' \
      "$txt"

   read -r lines < <(wc -l "$txt")
   info "Converted $structured_text to plain text with $lines lines"

   info "Converting $lines of plain text to raw audio ... stand by"
   pv <"$txt" | piper --model "$voice_model" \
      --output-file "$wav"

   info "Converting raw audio to MP3"
   #  redirect STDERR to function 'oneline'
   ffmpeg -i "$wav" "$target_mp3"

   # Set ID3 tags if author or book title provided
   if [ -n "$author" ] || [ -n "$book_title" ]; then
      info "Setting ID3 tags for $target_mp3"

      local tag_args=()

      if [ -n "$author" ]; then
         tag_args+=(-metadata "artist=$author")
         tag_args+=(-metadata "album_artist=$author")
      fi

      if [ -n "$book_title" ]; then
         tag_args+=(-metadata "album=$book_title")
      fi

      # Try to extract track number from filename
      local track_num
      track_num=$(extract_track_number "$structured_text")
      if [ -n "$track_num" ]; then
         tag_args+=(-metadata "track=$track_num")
         info "Detected track number: $track_num"
      fi

      # Create a temporary file for retagging
      temp_tagged="$(mktemp).mp3"
      register_for_cleanup "$temp_tagged"
      ffmpeg -i "$target_mp3" "${tag_args[@]}" -c copy "$temp_tagged"
      mv "$temp_tagged" "$target_mp3"
   fi

   info "Completed: $target_mp3"
}

# Process all input files
declare -a successes
declare -a fails

for structured_text in "$@"; do
   if [ ! -f "$structured_text" ]; then
      warn "File not found: $structured_text - skipping"
      fails+=("$structured_text")
      continue
   fi

   info "Processing file: $structured_text"
   if convert_file "$structured_text"; then
      successes+=("$structured_text")
   else
      fails+=("$structured_text")
   fi
done

[ ${#successes} -eq 0 ] || info Successfully processed:
for success in "${successes[@]}"; do
   echo "• $success"
done

[ ${#fails} -eq 0 ] || errortext Failed to process:
for fail in "${fails[@]}"; do
   echo "• $fail"
done
